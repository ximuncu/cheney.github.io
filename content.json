{"meta":{"title":"个人博客","subtitle":"我就是我，是颜色不一样的烟花。","description":"我就是我，是颜色不一样的烟花","author":"Cheney Liu","url":"http://www.cheneyliu.com"},"pages":[{"title":"","date":"2017-02-07T07:37:53.000Z","updated":"2017-02-07T07:37:53.000Z","comments":true,"path":"404.html","permalink":"http://www.cheneyliu.com/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2017-03-16T13:27:51.000Z","comments":true,"path":"archives/index.html","permalink":"http://www.cheneyliu.com/archives/index.html","excerpt":"","text":""},{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2017-03-16T11:09:12.000Z","comments":true,"path":"about/index.html","permalink":"http://www.cheneyliu.com/about/index.html","excerpt":"","text":"关于我前端攻城狮，目前就职于网易。2013年毕业后一直从事前端开发工作。"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2017-01-11T18:24:34.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.cheneyliu.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2017-01-11T18:24:34.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.cheneyliu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack中，带表达式的require语句","slug":"webpack中，带表达式的require语句","date":"2017-01-06T11:52:34.000Z","updated":"2017-03-26T13:57:28.000Z","comments":true,"path":"2017/01/06/webpack中，带表达式的require语句/","link":"","permalink":"http://www.cheneyliu.com/2017/01/06/webpack中，带表达式的require语句/","excerpt":"在我们的react项目中，偶尔会遇到这样的场景，就是我们需要加载一些动态的资源。我们知道es6中import只能加载静态的资源。所以加载就只剩下使用require方法。 比方说下面这个需求： 我们有个yml文件用于配置首页的banner相关信息，banner中包括图片及调整的链接地址","text":"在我们的react项目中，偶尔会遇到这样的场景，就是我们需要加载一些动态的资源。我们知道es6中import只能加载静态的资源。所以加载就只剩下使用require方法。 比方说下面这个需求： 我们有个yml文件用于配置首页的banner相关信息，banner中包括图片及调整的链接地址 123456# config.ymlbanner: - image: 'banner1.jpg' url: 'http://xxx.com' - image: 'banner1.jpg' url: 'http://xxx.com' 在我们的组件代码中需要导入这个banner 123456789101112131415//import React, &#123;Component&#125; from \"react\";import config from \"json!yaml!./config.yml\";export default class Banner extends Component&#123; render()&#123; const banner = config.banner.map((item)=&gt;&#123; return require(\"./image/\" + item.image); &#125;) return( &lt;div&gt; &#123;banner&#125; &lt;/div&gt; ) &#125;&#125; require(“./image/“ + item.image) 这个代码是不能加载到正确的模块的。 当我们使用require语句参数传入表达式的时候，webpack解析时，会创建一个模块上下文，并给模块分配id，再根据id进行加载。但是只是能解析一下非常简单的表达式。当表达式不能被正确解析加载到模块的时候，就需要我们自己来创建模块上下文 require.context方法中传入3个参数 要搜索的文件夹目录是否还应该搜索它的子目录以及一个匹配文件的正则表达式 比方上面的示例中进行修改 12345678910111213141516//Banner.jsimport React, &#123;Component&#125; from \"react\";import config from \"json!yaml!./config.yml\";export default class Banner extends Component&#123; render()&#123; let req = require.context(\"../image/\", true, /^.*\\.jpg/); const banner = config.banner.map((item)=&gt;&#123; return req(item.image); &#125;) return( &lt;div&gt; &#123;banner&#125; &lt;/div&gt; ) &#125;&#125; 创建自己的上下文加载即可","categories":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/categories/reactjs/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/tags/reactjs/"},{"name":"webpack","slug":"webpack","permalink":"http://www.cheneyliu.com/tags/webpack/"}]},{"title":"JavaScript如何实现继承","slug":"JavaScript如何实现继承","date":"2016-12-14T11:43:23.000Z","updated":"2017-04-05T15:21:58.000Z","comments":true,"path":"2016/12/14/JavaScript如何实现继承/","link":"","permalink":"http://www.cheneyliu.com/2016/12/14/JavaScript如何实现继承/","excerpt":"es6中我们通过 extends 关键字进行继承。但在这之前，我们要想做继承该怎么做呢。 简单原型链这个是比较简单的继承实现，就是将实例化一个父类对象，将其fu赋值给子类构造函数的prototype对象 代码实现：","text":"es6中我们通过 extends 关键字进行继承。但在这之前，我们要想做继承该怎么做呢。 简单原型链这个是比较简单的继承实现，就是将实例化一个父类对象，将其fu赋值给子类构造函数的prototype对象 代码实现： 123456789101112131415161718function Super()&#123; this.val = 1; this.arr = [1];&#125;function Sub()&#123; // ...&#125;Sub.prototype = new Super(); // 核心var sub1 = new Sub();var sub2 = new Sub();sub1.val = 2;sub1.arr.push(2);console.log(sub1.val); // 2console.log(sub2.val); // 1console.log(sub1.arr); // [1, 2]console.log(sub2.arr); // [1, 2] 但是这个存在一个问题，引用属性被共享的 借用构造函数借用构造函数就是子类构造函数中借用父类的构造函数 1234567891011121314151617181920212223function Super(val)&#123; this.val = val; this.arr = [1]; this.fun = function()&#123; // ... &#125;&#125;function Sub(val)&#123; Super.call(this, val); // 核心 // ...&#125;var sub1 = new Sub(1);var sub2 = new Sub(2);sub1.arr.push(2);console.log(sub1.val); // 1console.log(sub2.val); // 2console.log(sub1.arr); // [1, 2]console.log(sub2.arr); // [1]console.log(sub1.fun === sub2.fun); // false 借用构造函数解决了共享引用属性的问题。但是每个子类都生成一个新的方法，浪费内存 组合继承综合上面两种继承方式，使用原型来继承方法，使用借用构造函数来实现属性继承。 123456789101112131415161718function Super()&#123; // 只在此处声明基本属性和引用属性 this.val = 1; this.arr = [1];&#125;// 在此处声明函数Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;Sub.prototype = new Super(); // 核心var sub1 = new Sub(1);var sub2 = new Sub(2);console.log(sub1.fun === sub2.fun); // true 但这个模式也存在一个很小的问题，就是在子类原型上有一份多余的父类实例属性。 Super.call(this) 和 Sub.prototype = new Super() 中都调用了一份父类的构造函数。 寄生组合继承我们对组合继承做优化 也就是将 Sub.prototype = new Super() 这句进行优化。 12345var F = function()&#123;&#125;F.prototype = Super.prototype;var obj = new F();obj.constructor = Sub;Sub.prototype = obj; 我们构造了一个对象，将 Super.prototype 对象放到了这个对象的原型链上，并且将这个对象的constructor属性指向了子类构造函数。 优化后的继承 1234567891011121314151617181920212223242526function beget(obj)&#123; //对象生成一个对象，对象复制一样 var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function Super()&#123; // 只在此处声明基本属性和引用属性 this.val = 1; this.arr = [1];&#125;// 在此处声明函数Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;var proto = beget(Super.prototype); // 核心proto.constructor = Sub; // 核心Sub.prototype = proto; // 核心var sub = new Sub();console.log(sub.val); // 1console.log(sub.arr); // [1] 原型式原型式继承，其实应该说是一种对象复制继承也就是上面我们优化的那个部分 12345678910111213141516var oSuper = &#123; val : 1, arr : [1]&#125;function beget(obj)&#123; //对象生成一个对象，对象复制一样 var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;var oSub = beget(oSuper);oSub.attr1 = 1;oSub.attr2 = 2;console.log(oSub.val); // 1console.log(oSub.arr); // [1]console.log(oSub.attr1); // 1 es5中有个方法来替换 beget 方法，Object.create(); 寄生式寄生式继承可以认为是对原型式的一种封装，采用类似工程模式创建对象一样 1234567891011121314151617181920var oSuper = &#123; val : 1, arr : [1]&#125;function beget(obj)&#123; //对象生成一个对象，对象复制一样 var F = function()&#123;&#125;; F.prototype = obj; return new F();&#125;function getSubObject(obj)&#123; var clone = beget(obj); clone.attr1 = 1; clone.attr2 = 2; return clone;&#125;var oSub = getSubObject(oSuper);console.log(oSub.val); // 1console.log(oSub.arr); // [1]console.log(oSub.attr1); // 1","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]},{"title":"JavaScript如何构建对象","slug":"JavaScript如何构建对象","date":"2016-11-08T13:34:31.000Z","updated":"2017-04-05T08:36:39.000Z","comments":true,"path":"2016/11/08/JavaScript如何构建对象/","link":"","permalink":"http://www.cheneyliu.com/2016/11/08/JavaScript如何构建对象/","excerpt":"在JavaScript中构建对象有很多种方式，这里主要想说说的是es5中如何构建对象。es6中已经引入了类的概念，直接使用类去生成对象即可，但是在es5中，并没有提供一个这样的类。我们可以使用很多方法去构建对象。 工厂模式工厂模式就是使用参数初始化一个对象然后将对象返回出来。","text":"在JavaScript中构建对象有很多种方式，这里主要想说说的是es5中如何构建对象。es6中已经引入了类的概念，直接使用类去生成对象即可，但是在es5中，并没有提供一个这样的类。我们可以使用很多方法去构建对象。 工厂模式工厂模式就是使用参数初始化一个对象然后将对象返回出来。 123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; console.log(this.name); &#125; return o;&#125;var lily = createPerson(\"Lily\", \"14\", \"student\");var lucy = createPerson(\"Lucy\", \"23\", \"Doctor\"); 这个方法没有解决对象识别的问题。 构造函数模式构造函数模式采用的是使用构造函数去创建对象，并且使用了new这个关键字。 12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; console.log(this.name); &#125;&#125;var lily = new Person(\"Lily\", \"14\", \"student\");var lucy = new Person(\"Lucy\", \"23\", \"Doctor\"); 这样创建有个小问题，就是lily的sayName方法和lucy的sayName方法不是同一个。多一个对象其实就多定义了一个方法，占用了内存空间。 我们将sayName提到构造函数外面来 123456789function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName()&#123; console.log(this.name);&#125; 但是这样存在另一个问题，就是对象的方法不是只能对象方法的，而是在全局作用域了。也就没有对该方法起到封装的作用。 原型模式我们知道原型链，也就想到使用原型模式来创建对象 1234567function Person()&#123;&#125;Person.prototype.name = \"Lily\";Person.prototype.age = \"14\";Person.prototype.sayName = function()&#123; console.log(this.name);&#125; 不过这个方法创建的对象 name age 属性都是共享的。这并不是我们希望的。 组合构造和原型模式我们将构造模式和原型模式组合起来使用，构造函数中定义属性，原型中定义方法和共享的属性。这是目前最为常用的方式 12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job;&#125;Person.prototype.sayName = function()&#123; console.log(this.name);&#125;var lily = new Person(\"Lily\", \"14\", \"student\");var lucy = new Person(\"Lucy\", \"23\", \"Doctor\"); 当然我们可以对这个方式进行一点改动，在外观上更好的封装 12345678910111213function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; if(typeof this.sayName != \"function\")&#123; Person.prototype.sayName = function()&#123; console.log(this.name); &#125; &#125;&#125;var lily = new Person(\"Lily\", \"14\", \"student\");var lucy = new Person(\"Lucy\", \"23\", \"Doctor\"); 在初次调用构造函数时，给原型添加一个sayName方法","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]},{"title":"ES6设计模式-代理模式","slug":"ES6设计模式-代理模式","date":"2016-08-28T14:34:11.000Z","updated":"2017-04-05T15:14:13.000Z","comments":true,"path":"2016/08/28/ES6设计模式-代理模式/","link":"","permalink":"http://www.cheneyliu.com/2016/08/28/ES6设计模式-代理模式/","excerpt":"代理模式也比较好理解。比方说我想去图书馆找本书，但是我又不知道图书馆在哪里，有哪些图书馆。这时候呢我找了一个中介，他说只要告诉他我要什么书，他去图书馆帮我借，而且还是免费提供服务。这个中介就是一个代理。 就是代理那有些资源，或者提供跑腿服务，你直接让代理帮你去做事情。比方酒店提供机票预订服务，可以帮顾客预订机票。这也是代理。","text":"代理模式也比较好理解。比方说我想去图书馆找本书，但是我又不知道图书馆在哪里，有哪些图书馆。这时候呢我找了一个中介，他说只要告诉他我要什么书，他去图书馆帮我借，而且还是免费提供服务。这个中介就是一个代理。 就是代理那有些资源，或者提供跑腿服务，你直接让代理帮你去做事情。比方酒店提供机票预订服务，可以帮顾客预订机票。这也是代理。 下面我们用代码来实现一下图书馆找书代理模式实现 12345678910111213141516171819202122232425262728293031323334353637//Book类class Book &#123; constructor(title, author)&#123; this.title = title; this.author = author; &#125;&#125;//公共图书馆类class PublicLibrary &#123; constructor(books)&#123; this.books = books; &#125; //查找书籍 findBook(book)&#123; return this.books.find((item)=&gt;&#123; return (item.title === book.title &amp;&amp; item.author === book.author) &#125;) &#125;&#125;//公共图书馆代理class PublicLibraryProxy &#123; constructor(books)&#123; //代理了一个图书馆 this.library = new PublicLibrary(books); &#125; //查找书籍 findBook(book)&#123; return this.library.findBook(book); &#125;&#125;let book1 = new Book(\"人人都是产品经理\",\"苏杰\");let book2 = new Book(\"深入浅出Node.js\",\"朴灵\");let oProxyLibrary = new PublicLibraryProxy([book1,book2]);console.log(oProxyLibrary.findBook(book1).title);//输出 人人都是产品经理 代理模式常用于控制一些真实对象访问时的权限，一般用于对象应该有不同的访问权限。可以认为是某个对象的监护人。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/categories/设计模式/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.cheneyliu.com/tags/ES6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/tags/设计模式/"}]},{"title":"ES6设计模式-观察者模式","slug":"ES6设计模式-观察者模式","date":"2016-08-09T14:34:11.000Z","updated":"2017-04-05T15:13:37.000Z","comments":true,"path":"2016/08/09/ES6设计模式-观察者模式/","link":"","permalink":"http://www.cheneyliu.com/2016/08/09/ES6设计模式-观察者模式/","excerpt":"观察者模式，又叫做发布订阅模式。类似一种广播的方式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。 下面是封装了一个eventProxy 对象，提供的发布订阅的几个方法。","text":"观察者模式，又叫做发布订阅模式。类似一种广播的方式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。 下面是封装了一个eventProxy 对象，提供的发布订阅的几个方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// eventProxy.js'use strict';const eventProxy = &#123; onObj: &#123;&#125;, oneObj: &#123;&#125;, on: function(key, fn) &#123; if (this.onObj[key] === undefined) &#123; this.onObj[key] = []; &#125; this.onObj[key].push(fn); &#125;, one: function(key, fn) &#123; if (this.oneObj[key] === undefined) &#123; this.oneObj[key] = []; &#125; this.oneObj[key].push(fn); &#125;, off: function(key) &#123; this.onObj[key] = []; this.oneObj[key] = []; &#125;, trigger: function() &#123; let key, args; if (arguments.length == 0) &#123; return false; &#125; key = arguments[0]; args = [].concat(Array.prototype.slice.call(arguments, 1)); if (this.onObj[key] !== undefined &amp;&amp; this.onObj[key].length &gt; 0) &#123; for (let i in this.onObj[key]) &#123; this.onObj[key][i].apply(null, args); &#125; &#125; if (this.oneObj[key] !== undefined &amp;&amp; this.oneObj[key].length &gt; 0) &#123; for (let i in this.oneObj[key]) &#123; this.oneObj[key][i].apply(null, args); this.oneObj[key][i] = undefined; &#125; this.oneObj[key] = []; &#125; &#125;&#125;;export default eventProxy; 使用也比较简单 12345678910111213141516// main.jsimport eventProxy from \"./eventProxy.js\";//多个观察者对象中监听 \"CHANGE_STATE\" 事件，并且对这个事件进行处理eventProxy.on(\"CHANGE_STATE\",(msg)=&gt;&#123; console.log(\"对象一接收到信息，信息是：\" + msg);&#125;)eventProxy.on(\"CHANGE_STATE\",(msg)=&gt;&#123; console.log(\"对象二接收到信息，信息是：\" + msg);&#125;)//主题对象的状态发生变化，通知到其他观察者对象中eventProxy.trigger(\"CHANGE_STATE\",\"state改变了\");eventProxy.off(\"CHANGE_STATE\");","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/categories/设计模式/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.cheneyliu.com/tags/ES6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/tags/设计模式/"}]},{"title":"ES6设计模式-外观模式","slug":"ES6设计模式-外观模式","date":"2016-07-23T12:12:33.000Z","updated":"2017-03-30T03:12:48.000Z","comments":true,"path":"2016/07/23/ES6设计模式-外观模式/","link":"","permalink":"http://www.cheneyliu.com/2016/07/23/ES6设计模式-外观模式/","excerpt":"外观模式，顾名思义。就是提供一个类似于显示外观的接口，将内部实现进行隐藏掉。我们使用到了类库里经常用到。就好比方说，有个披萨店，给来店的顾客提供一个接口，orderPizza。而实际上这个orderPizza中其实含有很多流程，根据用户需要的披萨类型准备食材，厨房大厨如何制作等等。但是对于顾客来说都是不需要知道这些细节的。","text":"外观模式，顾名思义。就是提供一个类似于显示外观的接口，将内部实现进行隐藏掉。我们使用到了类库里经常用到。就好比方说，有个披萨店，给来店的顾客提供一个接口，orderPizza。而实际上这个orderPizza中其实含有很多流程，根据用户需要的披萨类型准备食材，厨房大厨如何制作等等。但是对于顾客来说都是不需要知道这些细节的。 又比方说我经常用到的添加事件的浏览器兼容处理。 123456789let addEvent = function (el, ev, fn) &#123; if (el.addEventListener) &#123; el.addEventListener(ev, fn, false); &#125; else if (el.attachEvent) &#123; el.attachEvent('on' + ev, fn); &#125; else &#123; el['on' + ev] = fn; &#125;&#125;; 又比方说，有个接口用户查询用户信息，而这个接口实现中需要查询很多东西，比方说查询用户名称，用户年龄，用户性别 12345678910export default function queryUserInfo()&#123; let name = queryUserName(); let age = queryUserAge(); let sex = queryUserSex(); return &#123; name, age, sex &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/categories/设计模式/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.cheneyliu.com/tags/ES6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/tags/设计模式/"}]},{"title":"ES6设计模式-工厂模式","slug":"ES6设计模式-工厂模式","date":"2016-07-16T12:14:23.000Z","updated":"2017-04-05T09:37:33.000Z","comments":true,"path":"2016/07/16/ES6设计模式-工厂模式/","link":"","permalink":"http://www.cheneyliu.com/2016/07/16/ES6设计模式-工厂模式/","excerpt":"工厂模式，就是在遇到需要根据环境创建不同实例时，我们定义一个创建实例的接口。通过这个接口的参数，去调用不同的构造函数来创建实例并返回。而这个接口就是一个创建对象的工厂，对象都是通过这个工厂创建出来的。","text":"工厂模式，就是在遇到需要根据环境创建不同实例时，我们定义一个创建实例的接口。通过这个接口的参数，去调用不同的构造函数来创建实例并返回。而这个接口就是一个创建对象的工厂，对象都是通过这个工厂创建出来的。 下面举个简单的例子。 首先我们先创建3个元素类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Image.jsexport default class Image &#123; constructor(option)&#123; let image = document.createElement(\"img\"); if(option.url)&#123; image.src = option.url; &#125; this._image = image; &#125; getDom()&#123; return this._image; &#125; insert(dom)&#123; dom.appendChild(this._image); &#125;&#125;//Link.jsexport default class Link &#123; constructor(option)&#123; let link = document.createElement(\"a\"); if(option.url)&#123; link.href = option.url; &#125; this._link = link; &#125; getDom()&#123; return this._link; &#125; insert(dom)&#123; dom.appendChild(this._link); &#125;&#125;//Text.jsexport default class Text &#123; constructor(option)&#123; let content = option.content || \"\" let text = document.createTextNode(content); this._text = text; &#125; getDom()&#123; return this._text; &#125; insert(dom)&#123; dom.appendChild(this._text); &#125;&#125; 我们再创建一个元素工厂类 12345678910111213141516171819//ElementFactory.jsimport Image from \"./Image.js\";import Link from \"./Link.js\";import Text from \"./Text.js\";const ELEMENT = &#123; \"image\" : Image, \"text\" : Text, \"link\" : Link&#125;export default class ElementFactory &#123; createElement(type, option)&#123; let ElementConstructor = ELEMENT(type), element = null; if(ElementConstructor)&#123; element = new ElementConstructor(option); &#125; return element; &#125;&#125; 测试我们的工厂类，创建一个实例text元素并且调用实例的insert方法 12345//main.jsimport ElementFactory from \"./ElementFactory.js\"let elementFactory = new ElementFactory();let text = elementFactory.createElement(\"text\", &#123;content: \"http://www.cheneyliu.com\"&#125;);text.insert(document.body);","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/categories/设计模式/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.cheneyliu.com/tags/ES6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/tags/设计模式/"}]},{"title":"ES6设计模式-装饰者模式","slug":"ES6设计模式-装饰者模式","date":"2016-07-10T14:36:43.000Z","updated":"2017-04-05T15:12:41.000Z","comments":true,"path":"2016/07/10/ES6设计模式-装饰者模式/","link":"","permalink":"http://www.cheneyliu.com/2016/07/10/ES6设计模式-装饰者模式/","excerpt":"当我们想给对象添加些各种的行为时，我们就可以使用装饰者模式了。这个从字面上就很好理解了。比方说我买了一辆低配车（new 出来了一个实例），这个时候呢我想给我这辆车添加一个配置，比方说添加了导航。这个时候我车的价格可能就需要加上我导航配置的钱的。 用代码来解释一下。","text":"当我们想给对象添加些各种的行为时，我们就可以使用装饰者模式了。这个从字面上就很好理解了。比方说我买了一辆低配车（new 出来了一个实例），这个时候呢我想给我这辆车添加一个配置，比方说添加了导航。这个时候我车的价格可能就需要加上我导航配置的钱的。 用代码来解释一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//BasicCar.jsexport default class BasicCar &#123; constructor(description = '这是一辆低配置') &#123; this.description = description; &#125; getDescription() &#123; return this.description; &#125; cost() &#123; return 30; //30w的低配车，豪车了，好想来一辆 &#125;&#125;//CarWithGPS.jsexport default class CarWithGps &#123; constructor(basicCar)&#123; this.basicCar = basicCar; &#125; getDescription()&#123; return this.basicCar.getDescription() + \"，加装了导航系统\"; &#125; cost() &#123; return this.basicCar.cost() + 0.8; &#125;&#125;//CarWithLed.jsexport default class CarWithLed &#123; constructor(basicCar)&#123; this.basicCar = basicCar; &#125; getDescription()&#123; return this.basicCar.getDescription() + \"，加装了LED大灯\"; &#125; cost() &#123; return this.basicCar.cost() + 0.5; &#125;&#125;//main.jsimport BasicCar from \"./BasicCar\";import CarWithGPS from \"./CarWithGPS\";import CarWithLed from \"./CarWithLed\";//买辆低配车let myCar = new BasicCar();//加装gps和led大灯myCar = new CarWithGps(myCar);myCar = new CarWithLed(myCar);console.log(myCar.getDescription());//这是一辆低配置，加装了导航系统，加装了LED大灯console.log(\"总共花费了我\" + myCar.cost() + \"万\");//总共花费了我31.3万 在买这辆车加装配置的时候其实用到的就是装饰者模式。CarWithGps和CarWithLed这两个类就是对我们原有的对象添加功能，修改一些行为。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/categories/设计模式/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.cheneyliu.com/tags/ES6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/tags/设计模式/"}]},{"title":"ES6设计模式-单例模式","slug":"ES6设计模式-单例模式","date":"2016-06-12T13:32:43.000Z","updated":"2017-04-05T15:12:12.000Z","comments":true,"path":"2016/06/12/ES6设计模式-单例模式/","link":"","permalink":"http://www.cheneyliu.com/2016/06/12/ES6设计模式-单例模式/","excerpt":"单例就是保证一个类只有一个实例。通常的实现方式是，先判断实例是否存在，如果存在直接将实例返回，如果不存在，就创建一个实例返回并且将这个实例保存起来。这样就保证了只有一个实例了。 实现单例模式的方式有很多种.我们可以根据实际情况灵活运用。","text":"单例就是保证一个类只有一个实例。通常的实现方式是，先判断实例是否存在，如果存在直接将实例返回，如果不存在，就创建一个实例返回并且将这个实例保存起来。这样就保证了只有一个实例了。 实现单例模式的方式有很多种.我们可以根据实际情况灵活运用。 直接使用对象字面量 1234567891011121314// Singleton.jsexport default &#123; property1 : \"property1\", property2 : \"property2\", method : function() &#123; console.log(\"hello world。\"); &#125;&#125;;//main.jsimport Singleton from './Singleton.js';let single1 = Singleton;let single2 = Singleton;console.log(single1 === single2); //输出true 当我们需要添加一些私有属性或者私有方法的时候（es6中也不支持私有属性及私有方法），我们可以使用闭包来实现，改写我们的Singleton.js 1234567891011121314151617//Singleton.jslet Singleton = (function () &#123; /* 这里声明私有变量和方法 */ var privateProperty = \"私有属性\"; function showPrivate() &#123; console.log(privateProperty); &#125; /* 公有变量和方法（可以访问私有变量和方法） */ return &#123; publicMethod: function () &#123; showPrivate(); &#125;, publicProperty: \"公共属性\" &#125;;&#125;)();export default Singleton; ES6中增加了对类的支持，我们也可以这样去实现单例模式 123456789101112131415161718//Person.jsexport default class Person &#123; constructor(name) &#123; if(Person.instance !== null)&#123; return Person.instance; &#125; this.name = name; Person.instance = this; &#125;&#125;Person.instance = null;//main.jsimport Person from './Person.js';let lily = new Person(\"lily\");let lucy = new Person(\"lucy\");console.log(lucy.name); // lilyconsole.log(lily === lucy); // true","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/categories/设计模式/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.cheneyliu.com/tags/ES6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.cheneyliu.com/tags/设计模式/"}]},{"title":"react组件生命周期详解--reactjs项目开发系列(5)","slug":"react组件生命周期详解--reactjs项目开发系列(5)","date":"2016-05-10T11:43:32.000Z","updated":"2017-03-26T12:25:43.000Z","comments":true,"path":"2016/05/10/react组件生命周期详解--reactjs项目开发系列(5)/","link":"","permalink":"http://www.cheneyliu.com/2016/05/10/react组件生命周期详解--reactjs项目开发系列(5)/","excerpt":"之前简单介绍了组件的生命周期，可分成三个状态： Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM 更加详细的生命周期可以参考下面这图：","text":"之前简单介绍了组件的生命周期，可分成三个状态： Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM 更加详细的生命周期可以参考下面这图： 接下来对几个比较常用到是生命周期进行讲解。 getInitialState这个常用来初始化state。对于每个组件的每个实例来说，这个方法只会被调用一次，这个方法中，可以访问到this.props相关的属性。 componentWillMount在完成首次渲染之前调用，此时仍可以修改组件的state。 render当然就是渲染了。这里是创建了一个虚拟dom，顶级组件只能出现一个。 componentDidMount真实的DOM被渲染出来后调用，也就是第一次render之后执行。可以使用一些方法获取到真实节点。比方说getDOMNode()、findDOMNode()，或者jquery这样的(不建议使用)。 我们也经常在这个方法中添加事件监听器。 shouldComponentUpdate组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法。这个常常用来进行性能优化。react使用一套diff算法来对是否需要更新做判断，当props或者state的指针修改了就认为数据修改了。实际应用中可能存在数据并未修改但指针修改的情况。此时在此方法中进行相关判断处理，可跳过后面的的生命周期优化性能。 componentWillUnmount组件被移除之前被调用，可以用于做一些清理工作。在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器 合理使用生命周期管理组件是react组件编写很重要的一部分。","categories":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/categories/reactjs/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/tags/reactjs/"},{"name":"webpack","slug":"webpack","permalink":"http://www.cheneyliu.com/tags/webpack/"}]},{"title":"react组件--reactjs项目开发系列(4)","slug":"react组件--reactjs项目开发系列(4)","date":"2016-04-26T12:23:20.000Z","updated":"2017-03-23T03:14:14.000Z","comments":true,"path":"2016/04/26/react组件--reactjs项目开发系列(4)/","link":"","permalink":"http://www.cheneyliu.com/2016/04/26/react组件--reactjs项目开发系列(4)/","excerpt":"React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。可以这么说，一个 React 应用就是构建在 React 组件之上的。在前面我们创建了一个简单组件。","text":"React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。可以这么说，一个 React 应用就是构建在 React 组件之上的。在前面我们创建了一个简单组件。 1234567891011121314151617//component.jsimport React, &#123; Component &#125; from 'react';export default class Hello extends Component &#123; render() &#123; return &lt;h1&gt;Hello world&lt;/h1&gt;; &#125;&#125;//在其他地方引用这个组件//main.jsimport React from 'react';import ReactDOM from 'react-dom';import Hello from './component.js';ReactDOM.render( &lt;Hello /&gt;, document.getElementById('app')); propsprops 就是组件的属性，例如上面的 组件，给它设置一些属性，在组件内容就能获取到这个属性,如： 12345678910111213import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Hello extends Component &#123; render() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;ReactDOM.render( &lt;Hello name = \"cheneyliu\" /&gt;, document.getElementById('app'));//页面将输出 Hello cheneyliu 父组件的数据可以通过设置子组件的props传递数据给子组件。这也是常见的组件通讯。有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor 。这是因为 class 和 for 是 JavaScript 的保留字。 this.props.children这个我比较少用到，props.children，它表示组件的所有子节点。 PropTypes组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求 12345678class Hello extends Component &#123; render() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;Hello.propTypes = &#123; name: React.PropTypes.string.isRequired&#125;; stateReact 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。 React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM） 1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class LikeButton extends Component &#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; let text = this.state.liked ? '喜欢' : '不喜欢'; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; 你&lt;b&gt;&#123;text&#125;&lt;/b&gt;我。点我切换状态。 &lt;/p&gt; ); &#125;&#125;;ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById('app')); JSXjsx其实就是一种javascript和html混写。 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析，比方上面例子中的 12345678render: function() &#123; let text = this.state.liked ? '喜欢' : '不喜欢'; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; 你&lt;b&gt;&#123;text&#125;&lt;/b&gt;我。点我切换状态。 &lt;/p&gt; );&#125; 组件的生命周期组件的生命周期可分成三个状态： Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM 这里只做简单的介绍一下。 api 以及 refs组件还提供一些api: 设置状态：setState （常用）替换状态：replaceState设置属性：setProps替换属性：replaceProps强制更新：forceUpdate获取DOM节点：findDOMNode （常用）判断组件挂载状态：isMounted React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上，比方说： 1&lt;input ref=\"myInput\" /&gt; 在其它代码中，通过 this.refs 获取实例: 1let input = this.refs.myInput;","categories":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/categories/reactjs/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/tags/reactjs/"},{"name":"webpack","slug":"webpack","permalink":"http://www.cheneyliu.com/tags/webpack/"}]},{"title":"创建一个reactjs项目(下)--reactjs项目开发系列(3)","slug":"创建一个reactjs项目(下)--reactjs项目开发系列(3)","date":"2016-04-20T13:42:44.000Z","updated":"2017-03-22T12:13:40.000Z","comments":true,"path":"2016/04/20/创建一个reactjs项目(下)--reactjs项目开发系列(3)/","link":"","permalink":"http://www.cheneyliu.com/2016/04/20/创建一个reactjs项目(下)--reactjs项目开发系列(3)/","excerpt":"上篇中讲到了如何创建一个简单的reactjs项目。但实际开发中，每次都需要打包然后刷新显得十分繁琐，并且在实际项目中，一般都是需要两个环境，及开发环境和生产环境。开发环境中当然是希望有热更新，修改完，直接浏览器就能看到输出结果；而生产环境就需要去除一些开发中使用到的工具，并且将一些资源打包之类的。","text":"上篇中讲到了如何创建一个简单的reactjs项目。但实际开发中，每次都需要打包然后刷新显得十分繁琐，并且在实际项目中，一般都是需要两个环境，及开发环境和生产环境。开发环境中当然是希望有热更新，修改完，直接浏览器就能看到输出结果；而生产环境就需要去除一些开发中使用到的工具，并且将一些资源打包之类的。 webpack-dev-serverWebpack给本地开发提供了一个可选的服务器webpack-dev-server。webpack-dev-server是一个小型的Node.js Express服务器,它使用webpack-dev-middleware来服务于webpack的包,除此自外，它还有一个通过Sock.js来连接到服务器的微型运行时。使用前需要用npm安装 1npm install webpack-dev-server --save 我们需要对package.json进行修改 12345\"main\": \"webpack.config.js\",\"scripts\": &#123; \"dev\": \"webpack-dev-server --progress --profile --colors --hot\", \"build\": \"webpack --progress --profile --colors --config webpack.production.config.js\"&#125; 执行 npm run dev 时，当前项目根目录会作为web根目录。所以在当前项目根目录添加index.html文件 执行后我们就能看到服务器启动了，直接访问 http://localhost:8080/ (可能其他端口)就能看到我们写的代码跑起来了。修改一下引用到的组件的内容，浏览器自动更新。方便多了。 webpack.production.config.js生成环境的webpackconfig配置可能存在部分差异 123456789101112131415161718192021222324252627282930313233343536var path = require('path');var webpack = require(\"webpack\");var HtmlWebpackPlugin = require(\"html-webpack-plugin\");var ROOT_PATH = path.resolve(__dirname);var APP_PATH = path.resolve(ROOT_PATH, \"app\");var BUILD_PATH = path.resolve(ROOT_PATH, \"build\");var NODE_PATH = path.resolve(ROOT_PATH, \"node_modules\");var config = &#123; entry: path.resolve(APP_PATH, \"index.js\"), output: &#123; path: BUILD_PATH, filename: 'bundle.js' &#125;, module: &#123; loaders: [&#123; test: /\\.jsx?$/, // 用正则来匹配文件路径，这段意思是匹配 js 或者 jsx loader: 'babel-loader', include : APP_PATH, exclude : NODE_PATH, query: &#123; presets:[\"es2015\", \"react\"] &#125; &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template : \"./index.html\" &#125;),//以当前根目录下的index.html为模板创建 new webpack.DefinePlugin(&#123; PRODUCTION: JSON.stringify(true), &#125;) //定义一个区分开发环境很生产环境的常量 ]&#125;;module.exports = config; 这里需要安装一下 html-webpack-plugin ，这个插件用来简化创建服务于 webpack bundle 的 HTML 文件。 执行 npm run build，可以在 output 中指定的 path中生成 bundle.js和index.html文件。 这样开发环境和生产环境就能单独进行控制了。开发起来也特别方便。","categories":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/categories/reactjs/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/tags/reactjs/"},{"name":"webpack","slug":"webpack","permalink":"http://www.cheneyliu.com/tags/webpack/"}]},{"title":"创建一个reactjs项目(上)--reactjs项目开发系列(2)","slug":"创建一个reactjs项目(上)--reactjs项目开发系列(2)","date":"2016-04-16T12:33:14.000Z","updated":"2017-03-22T12:10:40.000Z","comments":true,"path":"2016/04/16/创建一个reactjs项目(上)--reactjs项目开发系列(2)/","link":"","permalink":"http://www.cheneyliu.com/2016/04/16/创建一个reactjs项目(上)--reactjs项目开发系列(2)/","excerpt":"创建一个简单的reactjs项目并不复杂。 创建环境需要安装了node环境。例如1234node -v//v6.8.0npm -v//3.10.8 创建项目目录mkdir创建一个目录，使用 npm init 初始化，填入相关的项目信息","text":"创建一个简单的reactjs项目并不复杂。 创建环境需要安装了node环境。例如1234node -v//v6.8.0npm -v//3.10.8 创建项目目录mkdir创建一个目录，使用 npm init 初始化，填入相关的项目信息 安装需要的模块1234567npm install react --savenpm install react-dom --savenpm install webpack --savenpm install babel-loader --savenpm install babel-core --savenpm install babel-preset-es2015 --save //对es6的支持npm install babel-preset-react --save //对react的支持 配置好启动脚本创建完之后的package.json如下 1234567891011121314151617181920212223242526//package.json&#123; \"name\": \"react-demo\", \"version\": \"1.0.0\", \"description\": \"reactjsdemo\", \"main\": \"webpack.config.js\", \"scripts\": &#123; \"build\": \"webpack --progress --profile --colors\" //设置启动脚本 &#125;, \"keywords\": [ \"reacjs\" ], \"author\": \"cheneyliu\", \"license\": \"MIT\", \"dependencies\": &#123; \"babel-core\": \"^6.24.0\", \"babel-preset-es2015\": \"^6.24.0\", \"babel-preset-react\": \"^6.23.0\", \"react\": \"^15.4.2\", \"react-dom\": \"^15.4.2\", \"webpack\": \"^2.2.1\" &#125;, \"devDependencies\": &#123; \"babel-loader\": \"^6.4.1\" &#125;&#125; 创建webpack.config.js文件1234567891011121314151617181920//webpack.config.jsvar path = require('path');var config = &#123; entry: path.resolve(__dirname, 'app/main.js'), output: &#123; path: path.resolve(__dirname, 'build'), //打包到build目录下 filename: 'bundle.js' &#125;, module: &#123; loaders: [&#123; test: /\\.jsx?$/, // 用正则来匹配文件路径，这段意思是匹配 js 或者 jsx loader: 'babel-loader', query: &#123; presets:[\"es2015\", \"react\"] //解析react 以及es6 &#125; &#125;] &#125;&#125;;module.exports = config; 创建index.htmlbuild下创建index.html 1234567891011&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt; &lt;!-- 引入打包好的bundle.js --&gt; &lt;/body&gt;&lt;/html&gt; 创建main.jsapp目录下创建main.js文件 12345678//main.jsimport React from 'react';import ReactDOM from 'react-dom';import Hello from './component.js'; //引入一个React组件ReactDOM.render( &lt;Hello /&gt;, document.getElementById('app')); 创建component.jsapp目录下创建component.js文件，及创建react组件 1234567//component.jsimport React, &#123; Component &#125; from 'react';export default class Hello extends Component &#123; render() &#123; return &lt;h1&gt;Hello world&lt;/h1&gt;; &#125;&#125; 以上内容使用的es6相关语法。 运行打包项目根目录下 执行 npm run build，即可执行打包 访问build下的index.html就能看到我们输出的 “Hello world” 了。","categories":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/categories/reactjs/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/tags/reactjs/"},{"name":"webpack","slug":"webpack","permalink":"http://www.cheneyliu.com/tags/webpack/"}]},{"title":"webpack初探--reactjs项目开发系列(1)","slug":"webpack初探-reactjs项目开发系列(1)","date":"2016-04-12T14:08:10.000Z","updated":"2017-03-20T01:41:46.000Z","comments":true,"path":"2016/04/12/webpack初探-reactjs项目开发系列(1)/","link":"","permalink":"http://www.cheneyliu.com/2016/04/12/webpack初探-reactjs项目开发系列(1)/","excerpt":"新起的项目，经过深思熟虑之后决定采用时下流行的reactjs进行开发。为此在学习的同时也想分享一些自己的认识及遇到的奇怪问题。 做为第一篇，我想先讲讲webpack这个工具。 webpack简介Webpack是当下最热门的前端资源模块化管理和打包工具。以前用过grunt，之后出现过gulp，这些工具目的都是一样的，前端自动化构建工具。前端自动化，听上去就很厉害。个人理解webpack，其实还是比较简单，像有一堆乱七八糟的东西（webpack认为是资源，当做模块处理，像js,css,less,图片等等文件），经过webpack的梳理解析及分类打包成你想要的样子。","text":"新起的项目，经过深思熟虑之后决定采用时下流行的reactjs进行开发。为此在学习的同时也想分享一些自己的认识及遇到的奇怪问题。 做为第一篇，我想先讲讲webpack这个工具。 webpack简介Webpack是当下最热门的前端资源模块化管理和打包工具。以前用过grunt，之后出现过gulp，这些工具目的都是一样的，前端自动化构建工具。前端自动化，听上去就很厉害。个人理解webpack，其实还是比较简单，像有一堆乱七八糟的东西（webpack认为是资源，当做模块处理，像js,css,less,图片等等文件），经过webpack的梳理解析及分类打包成你想要的样子。 webpack四个核心概念入口(Entry)作为一个打包工具，当然需要知道从哪里开始整理。就像这样配置： 123456789101112//单一入口（简写）module.exports = &#123; entry: './path/to/my/entry/file.js'&#125;;//对象写法（常用）module.exports = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js'//静态库 &#125;&#125; 出口(Output)有入口当然就会有出口，就是将所有资源打包到哪里。 12345678910//简单示例const path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;&#125;; 这只是一个很简单的示例，output还有很多属性。这里需要注意一个，当启用热更新，并且有多级路由的时候，会发现热更新无法使用的情况(热更新的文件找不到了)，这个时候就需要用到output的两个属性了。配置热更的两个文件路径 123456output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' hotUpdateChunkFilename: '/hot-update.js', hotUpdateMainFilename: '/hot-update.json'&#125; 加载器(Loaders)webpack对有些文件是不认识的。这个时候就需要loaders来告诉webpack了。 12345678910111213141516171819202122module.exports = &#123; module: &#123; loaders : [&#123; test: /\\.css$/, loader: 'style!css' &#125;,&#123; test : /\\.less$/, loader: \"style!css!less\" &#125; ] &#125;&#125;;//新版已经对这个配置字段进行了修改module.exports = &#123; module: &#123; rules: [ &#123;test: /\\.css$/, use: 'css-loader'&#125;, &#123;test: /\\.ts$/, use: 'ts-loader'&#125; ] &#125;&#125;; 新版中使用rules替换了loaders， use替换了loader,并且不支持省略”-loader”及不支持”!”。具体区别可以参考网上资料 插件(Plugins)最后一个重要的东西就是插件了。插件其实就是去丰富webpack的功能，比方说UglifyJs，提取css到一个文件里等等。 123456789101112131415161718192021222324const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; loaders: [ &#123; test: /\\.(js|jsx)$/, loader: 'babel-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;)//使用html模板构造index页面 ]&#125;;module.exports = config; 当然webpack里面的配置功能不止上面说这些。不过这些知识点就足以应付很多需求了","categories":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/categories/reactjs/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"http://www.cheneyliu.com/tags/reactjs/"},{"name":"webpack","slug":"webpack","permalink":"http://www.cheneyliu.com/tags/webpack/"}]},{"title":"==和===","slug":"==和===","date":"2015-08-11T16:08:17.000Z","updated":"2017-03-16T13:27:55.000Z","comments":true,"path":"2015/08/12/==和===/","link":"","permalink":"http://www.cheneyliu.com/2015/08/12/==和===/","excerpt":"Object 的 valueOf 方法valueOf()函数返回指定对象的原始值。 JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。","text":"Object 的 valueOf 方法valueOf()函数返回指定对象的原始值。 JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。 Object 的 toString() 方法toString()函数的返回值为String类型。返回当前对象的字符串形式。 JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要 “==” 与 “===”“===” 和 “==” 都是用来比较两个值是否相等。前者称为严格相等运算符，判断是否严格相等；后者称为相等运算符，判断是否相等，这个是允许类型转换的。 “===” 这个判断比较简单1.如果数据类型不一样则不相等 2.如果是引用类型，除非指向同一个数组、对象这样的，那么相等，其他都不相等 3.其他比较就是常规的比较了 “==” 这个比较复杂如果都是引用类型，或者同是基本类型，同”===” null 和 undefined 相等 1.一个是数字，另一个字符串，字符串转换为数字后比较 2.含有一个boolean值，先将其转换为数字后比较 3.其中一个值是对象，将其转换为原始值进行比较(字符串或者数字，根据情况来转换)。 对象转换为原始值对象转换为boolean比较简单，都是为true 对象转换为数字，先调用valueOf方法，如果为原始值，转换为数字（需要的话）；不成功则调用toString()方法，如果为原始值，转换为数字（需要的话），也不成功就抛出异常 对象转换为字符串，同样的，先调用toString()方法，如果为原始值，转换为字符串（需要的话）；不成功则调用valueOf()方法，，如果为原始值，转换为字符串（需要的话），也不成功就抛出异常 转换的时候到底转换为数字还是字符串，这个看情况需要。 举几个例子 1234567new Date() + 1//\"Tue Aug 11 2015 23:35:47 GMT+0800 (中国标准时间)1\"//+ 期望前面的值是一个字符串，调用的Date的toString()方法+new Date()//1439307361984//+ 期望后面的值是一个数字，调用的Date的valueOf()方法处理 举几个”==”的例子123456789101112[] == ![]//第一步：![] 转换为boolean值为false//第二步：false 转换为数字为 0//第三步：[] 转换为数字为 0//判断为true ,第二步和第三步谁先都没有关系\"1\" == true// true 转换为 1// \"1\" 转换为 1\"1,2\" == [1,2]// [1,2] 转换为字符串 \"1,2\"","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]},{"title":"高效操作DOM","slug":"高效操作DOM","date":"2015-08-09T13:21:37.000Z","updated":"2017-03-16T13:27:49.000Z","comments":true,"path":"2015/08/09/高效操作DOM/","link":"","permalink":"http://www.cheneyliu.com/2015/08/09/高效操作DOM/","excerpt":"DOM树与Render树这个应该都是知道的。就是用户请求HTML下来后，浏览器渲染引擎的基本工作中两个概念。 copy一张图，流程大概就是：解析html构建DOM树，渲染树构建，渲染树布局，绘制渲染树。 这里要注意的一点是，DOM树和render树并不是简单的一一对应关系。render树中并不包含那些不需要渲染的节点。比方说head、title这样的；display：none也是不会有的；还有一些设置position:absolute，fixed，构造render树时会根据实际情况来构造。","text":"DOM树与Render树这个应该都是知道的。就是用户请求HTML下来后，浏览器渲染引擎的基本工作中两个概念。 copy一张图，流程大概就是：解析html构建DOM树，渲染树构建，渲染树布局，绘制渲染树。 这里要注意的一点是，DOM树和render树并不是简单的一一对应关系。render树中并不包含那些不需要渲染的节点。比方说head、title这样的；display：none也是不会有的；还有一些设置position:absolute，fixed，构造render树时会根据实际情况来构造。 重绘(redraw)和重排(reflow)从字面上就是能理解了，重绘就是重新绘制，重排就是重构render树。这两个都是负担很重的操作，比方说table tree中显示隐藏，浏览器需要重排，重绘，如果子节点比较多，有可能页面就卡死了（ie6、7这样的老古董很容易会这样）。所以这样的事情我们尽量少做，也就是写js的时候尽量少些这样类型的代码。 而重排一般都是下面这样的操作引起的（尽量少的使用）。 1.添加、删除可见的DOM元素(visibility:hidden也算，不要为为什么)2.元素的位置改变3.元素尺寸改变，也就是盒子模型中的属性改变4.内容改变（文本加长了，图片尺寸改变）5.浏览器窗格改变大小6.获取某些属性（offset，scroll，client**） 最小化重绘与重排1.合并css操作为一次操作2.当要批量修改dom时，先将该元素中文档流中摘除，对其使用多重改变，最后将元素带回文档中。（设置display：none;使用DocumentFragment;clone一个节点）3.在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。4.将需要多次重排的元素（比方说动画），position属性设为absolute或fixed，使其脱离文档流，这样它的变化不会影响到其他元素。 DOM 真的很慢如果把ECMAScript看做一个孤岛，DOM看做一个孤岛，DOM访问看成是过桥的话，每次DOM访问都是需要”过桥费”的。过的多，费用就越高，也就越消耗性能。所以尽量减少DOM的访问。比方缓存获取下来的DOM元素。","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]},{"title":"javascript作用域链","slug":"javascript作用域链","date":"2015-08-02T15:30:01.000Z","updated":"2017-03-23T02:58:05.000Z","comments":true,"path":"2015/08/02/javascript作用域链/","link":"","permalink":"http://www.cheneyliu.com/2015/08/02/javascript作用域链/","excerpt":"最近想整理一下js执行代码的一些知识，如果有出错的地方还请指正。 执行环境(Execution Context)所有的javascript代码都是在一个执行环境中被执行的。它只是一种机制，用来完成运行时作用域、生存期等方面的处理。 代码分为三种类型： 1.Global Code2.Eval Code3.Function Code 这是一个EC结构 可以理解如下： 12345678activeExecutionContext = &#123; VO: &#123;...&#125;, // or AO this: thisValue, Scope: [ // Scope chain // 所有变量对象的列表 // for identifiers lookup ]&#125;;","text":"最近想整理一下js执行代码的一些知识，如果有出错的地方还请指正。 执行环境(Execution Context)所有的javascript代码都是在一个执行环境中被执行的。它只是一种机制，用来完成运行时作用域、生存期等方面的处理。 代码分为三种类型： 1.Global Code2.Eval Code3.Function Code 这是一个EC结构 可以理解如下： 12345678activeExecutionContext = &#123; VO: &#123;...&#125;, // or AO this: thisValue, Scope: [ // Scope chain // 所有变量对象的列表 // for identifiers lookup ]&#125;; 当一段程序开始时，会先进入到全局执行上下文环境。此时如果调用了某些函数，就会进入他们的上下文环境，执行完之后再退出该上下文环境。 假设激活了一个EC1的上下文，图解如下 变量对象(VO)和活动对象(AO)变量对象是一个与上下文相关的数据作用域，用于存储被定义在上下文中的变量和函数声明（不包括函数表达式）。在global全局上下文中，变量对象即使全局对象自身。 copy一个例子 1234567891011var foo = 10;function bar() &#123;&#125; // // 函数声明(function baz() &#123;&#125;); // 函数表达式console.log( this.foo == foo, // true window.bar == bar // true);console.log(baz); // 引用错误，baz没有被定义 全局上下文中的变量对象(VO)会有如下属性： 在一个函数的上下文中，变量对象被表示为活动对象 活动对象在进入上下文中初始化成了 123AO = &#123; arguments: &lt;ArgO&gt;&#125;; arguments属性值就是Arguments对象 之后就是存储当前上下文的变量与函数声明 作用域链作用域链是一个 对象列表，用于检索上下文中出现的 标识符（变量名称、函数声明，普通参数）。在函数创建的时候，当前的作用域链被存储到了函数的[[scope]]属性中。当进入上下文创建AO/VO之后，上下文(EC)的Scope属性作了如下处理： 1Scope = AO|VO + [[Scope]] 知识点就是这些，现在我们来一段代码，把过程给串联起来。在这之前，我们要知道另一个知识，就是执行上下文的代码被分成两个基本的阶段来处理 1.进入执行上下文2.执行代码 1234567891011121314var x = 10;function foo(m) &#123; var y = 20; function bar() &#123; var z = 30; alert(x + y + z + m); &#125; bar();&#125;foo(10); // 60 首先先进入全局上下文环境 全局上下文的变量对象(代码执行时，x才被赋值)是： 1234globalContext.VO === Global = &#123; x: 10 foo: &lt;reference to function&gt;&#125;; globalContext.Scope = globalContext.VO; 当”foo”创建时， 1234567foo.[[Scope]] = [ globalContext.Scope];//也就是foo.[[Scope]] = [ globalContext.VO]; 在”foo”激活时，进入了foo的上下文，foo上下文中的活动对象(代码执行时，y才被赋值)是： 123456fooContext.AO = &#123; arguments:&lt;Arg&gt;, m: 10, y: 20, bar: &lt;reference to function&gt;&#125;; 此时foo上下文中的作用域链为： 12345fooContext.Scope = fooContext.AO + foo.[[Scope]] // i.e.:fooContext.Scope = [ fooContext.AO, globalContext.VO]; 函数”bar”创建时，其[[scope]]为: 123456bar.[[Scope]] = fooContext.Scope;//也就是bar.[[Scope]] = [ fooContext.AO, globalContext.VO]; 同理，bar就不写了。最后bar上下文的作用域链为: 123456barContext.Scope = barContext.AO + bar.[[Scope]]barContext.Scope = [ barContext.AO, fooContext.AO, globalContext.VO]; 在alert执行时，作用域链中查找标示符如下 查找 x, barContext.AO 无 —-&gt; fooContext.AO 无 —-&gt;globalContext.VO 有查找 Z, barContext.AO 有 其他的就自己看了。 局部变量、全局变量在作用域链中查找标识符是需要花时间的，所以就明白为什么需要尽量使用局部变量(将频繁使用的全局变量缓存下来)，全局变量尽量少用了。并且with会破坏作用域链，它会将指定的VO/AO加入到作用域链的顶端，这样在标识符查找时，需要查找更长的作用域链。 闭包理解了上面的概念，闭包就很容易理解了。闭包是代码块和创建该代码块的上下文中数据的结合。","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]},{"title":"javascript原型和原型链","slug":"javascript原型和原型链","date":"2015-07-29T15:12:27.000Z","updated":"2017-03-16T11:19:22.000Z","comments":true,"path":"2015/07/29/javascript原型和原型链/","link":"","permalink":"http://www.cheneyliu.com/2015/07/29/javascript原型和原型链/","excerpt":"最近几天，好些新同事来问原型，原型链啥的。本身作为菜鸟的我好像也没有好好整理过这个，这里写写自己的理解。 原型大家都知道，JavaScript 不包含传统的类继承模型，而是使用 prototype 原型模型。代码实现大概是这样子的 123456789101112function Student(name)&#123; this.name = name;&#125;var Kimy = new Student(\"Kimy\");Student.prototype.say = function()&#123; console.log(this.name + \"say\");&#125;Kimy.say();//Kimysay Kimy本身是没有say方法的，当他在自己对象中找不到该方法时就回去他的原型中查找，也就是Student.prototype对象中查找。这里我们用到了一个构造函数Student","text":"最近几天，好些新同事来问原型，原型链啥的。本身作为菜鸟的我好像也没有好好整理过这个，这里写写自己的理解。 原型大家都知道，JavaScript 不包含传统的类继承模型，而是使用 prototype 原型模型。代码实现大概是这样子的 123456789101112function Student(name)&#123; this.name = name;&#125;var Kimy = new Student(\"Kimy\");Student.prototype.say = function()&#123; console.log(this.name + \"say\");&#125;Kimy.say();//Kimysay Kimy本身是没有say方法的，当他在自己对象中找不到该方法时就回去他的原型中查找，也就是Student.prototype对象中查找。这里我们用到了一个构造函数Student 构造函数、proto以及原型链除了IE浏览器，其他浏览器都在Object对象的实例上，部署了一个非标准的proto属性（前后各两个下划线），指向该对象的原型对象，即构造函数的prototype属性。 盗用一段代码和一张图 123456789101112131415161718192021222324252627282930313233// 构造方法function Foo(y) &#123; this.y = y;&#125;Foo.prototype.x = 10;// 继承方法\"calculate\"Foo.prototype.calculate = function (z) &#123; return this.x + this.y + z;&#125;;// 使用foo模式创建 \"b\" and \"c\"var b = new Foo(20);var c = new Foo(30);// 调用继承的方法b.calculate(30); // 60c.calculate(40); // 80console.log( b.__proto__ === Foo.prototype, // true c.__proto__ === Foo.prototype, // true b.constructor === Foo, // true c.constructor === Foo, // true Foo.prototype.constructor === Foo // true b.calculate === b.__proto__.calculate, // true b.__proto__.calculate === Foo.prototype.calculate // true); 我们可以看到，每个对象都是含有一个proto属性，b的proto指向的构造b的构造方法Foo的prototype属性；而Foo.prototype也是一个对象，本身也有一个proto指向构造其的构造方法Object的prototype。Object.prototype的proto被指向了 null, 这就形成了一个原型链了。 这里还要能理解这样一段代码 1234Object instanceof Function//trueFunction instanceof Object//true new做了什么这里还有一个小问题，js里面普通函数和构造函数形式上貌似没有啥太大区别(首字母大写不是必须的，但是通常都把构造函数的首字母大写)。new这个关键字到底做了什么东西。 比方 1var Kimy = new Student(); new 做了三件事情12345var Kimy = &#123;&#125;;Kimy.__proto__ = Student.prototype;Student.call(Kimy); 1、定义了一个空对象2、设置其原型3、初始化对象 这样就能理解为什么Kimy.proto指向的是Student.prototype了(同一个引用)，原来就是new在起着关键的作用！","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]},{"title":"setTimeout与setInterval","slug":"setTimeout与setInterval","date":"2015-06-22T15:23:33.000Z","updated":"2017-03-16T11:19:17.000Z","comments":true,"path":"2015/06/22/setTimeout与setInterval/","link":"","permalink":"http://www.cheneyliu.com/2015/06/22/setTimeout与setInterval/","excerpt":"最新写代码中时，看到项目中有人用到了 setTimeout(fun,0)，于是想总结一下。个人理解，如果有错误的地方还请指出。THX 要想理解JavaScript的定时器是如何工作的，先要明白 JavaScript 引擎是单线程的。这个可以理解为 javascript 引擎是一个服务员，它有一个服务的队列，所有的界面元素事件,定时触发器回调，异步请求回调都要在这个任务队列里排队，等待处理。所有任务都是一个最小单位，不会中断处理。这样就可以理解 setTimeout(fun,0) 了，它并不是代表立即执行该代码，除非任务队列为空(事实上，各个浏览器在实际执行这个的时候也是有差异了，比较新的浏览器实际可能是在4ms；老版本的可能更长一点，16ms也是可能的)。而 setTimeout(fun,time) 的意思就是多少时间后将 fun 回调加到这个任务队列中，也就是至少需要time时间才会执行fun。 举个例子： 12345678setTimeout(function () &#123; console.log(1);&#125;, 0);var tem = 0;for (var i = 1; i &lt; 1000000; i++) &#123; tem += i;&#125;;console.log(2); 显示结果为1221 就是说，在执行 setTimeout 时，将 function 回调加入了任务队列，但并没有立即执行，因为js引擎还在忙着处理当前的js，而只在这段代码段执行完才去任务列表里取新的任务，所以结果就是先显示 2 后显示 1。","text":"最新写代码中时，看到项目中有人用到了 setTimeout(fun,0)，于是想总结一下。个人理解，如果有错误的地方还请指出。THX 要想理解JavaScript的定时器是如何工作的，先要明白 JavaScript 引擎是单线程的。这个可以理解为 javascript 引擎是一个服务员，它有一个服务的队列，所有的界面元素事件,定时触发器回调，异步请求回调都要在这个任务队列里排队，等待处理。所有任务都是一个最小单位，不会中断处理。这样就可以理解 setTimeout(fun,0) 了，它并不是代表立即执行该代码，除非任务队列为空(事实上，各个浏览器在实际执行这个的时候也是有差异了，比较新的浏览器实际可能是在4ms；老版本的可能更长一点，16ms也是可能的)。而 setTimeout(fun,time) 的意思就是多少时间后将 fun 回调加到这个任务队列中，也就是至少需要time时间才会执行fun。 举个例子： 12345678setTimeout(function () &#123; console.log(1);&#125;, 0);var tem = 0;for (var i = 1; i &lt; 1000000; i++) &#123; tem += i;&#125;;console.log(2); 显示结果为1221 就是说，在执行 setTimeout 时，将 function 回调加入了任务队列，但并没有立即执行，因为js引擎还在忙着处理当前的js，而只在这段代码段执行完才去任务列表里取新的任务，所以结果就是先显示 2 后显示 1。 setInterval(fun, time)方法是，每隔一定时间将fun添加到队列中，那么问题来，如果fun执行时间比 time 要长的时候怎么办？ 看一段代码 12345678910111213var num = 0;var time = setInterval(function () &#123; var tem = 0; for (var i = 1; i &lt; 99999999; i++) &#123; tem += i; &#125;; num ++; console.log(num);&#125;, 100);setTimeout(function ()&#123; clearInterval(time);&#125;, 1000); 意思是每隔100ms执行一段代码，在1s中后清除这个定时器。但是结果呢？ 显示结果为 123123 也就是说，事实上，并没有执行到那么多次数。也就是说某些间隔会被跳过，这也就存在多个代码执行的间隔可能会比预期的小。原来在将定时器代码加入队列的时候，如果该定时器的代码实例存在时，该次定时器代码会被跳过。引用一张图片，就很好理解了。","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]}]}