{"meta":{"title":"个人博客","subtitle":"我就是我，是颜色不一样的烟花。","description":"我就是我，是颜色不一样的烟花","author":"Cheney Liu","url":"http://www.cheneyliu.com"},"pages":[{"title":"","date":"2017-02-07T07:37:53.000Z","updated":"2017-02-07T07:37:53.000Z","comments":true,"path":"404.html","permalink":"http://www.cheneyliu.com/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2017-02-08T12:39:44.000Z","comments":true,"path":"about/index.html","permalink":"http://www.cheneyliu.com/about/index.html","excerpt":"","text":"姓名刘乾 职业web前端攻城狮"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2017-01-11T18:24:34.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.cheneyliu.com/categories/index.html","excerpt":"","text":""},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2017-01-11T18:24:34.000Z","comments":true,"path":"archives/index.html","permalink":"http://www.cheneyliu.com/archives/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2017-01-11T18:24:34.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.cheneyliu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"==和===","slug":"==和===","date":"2015-08-11T16:08:17.000Z","updated":"2017-02-14T02:30:46.000Z","comments":true,"path":"2015/08/12/==和===/","link":"","permalink":"http://www.cheneyliu.com/2015/08/12/==和===/","excerpt":"Object 的 valueOf 方法valueOf()函数返回指定对象的原始值。JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。","text":"Object 的 valueOf 方法valueOf()函数返回指定对象的原始值。JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。 Object 的 toString() 方法toString()函数的返回值为String类型。返回当前对象的字符串形式。JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要 “==” 与 “===”“===” 和 “==” 都是用来比较两个值是否相等。前者称为严格相等运算符，判断是否严格相等；后者称为相等运算符，判断是否相等，这个是允许类型转换的。 “===” 这个判断比较简单1.如果数据类型不一样则不相等2.如果是引用类型，除非指向同一个数组、对象这样的，那么相等，其他都不相等3.其他比较就是常规的比较了 “==” 这个比较复杂如果都是引用类型，或者同是基本类型，同”===”null 和 undefined 相等1.一个是数字，另一个字符串，字符串转换为数字后比较2.含有一个boolean值，先将其转换为数字后比较3.其中一个值是对象，将其转换为原始值进行比较(字符串或者数字，根据情况来转换)。 对象转换为原始值对象转换为boolean比较简单，都是为true对象转换为数字，先调用valueOf方法，如果为原始值，转换为数字（需要的话）；不成功则调用toString()方法，如果为原始值，转换为数字（需要的话），也不成功就抛出异常对象转换为字符串，同样的，先调用toString()方法，如果为原始值，转换为字符串（需要的话）；不成功则调用valueOf()方法，，如果为原始值，转换为字符串（需要的话），也不成功就抛出异常转换的时候到底转换为数字还是字符串，这个看情况需要。举几个例子1234567new Date() + 1//\"Tue Aug 11 2015 23:35:47 GMT+0800 (中国标准时间)1\"//+ 期望前面的值是一个字符串，调用的Date的toString()方法+new Date()//1439307361984//+ 期望后面的值是一个数字，调用的Date的valueOf()方法处理 举几个”==”的例子123456789101112[] == ![]//第一步：![] 转换为boolean值为false//第二步：false 转换为数字为 0//第三步：[] 转换为数字为 0//判断为true ,第二步和第三步谁先都没有关系\"1\" == true// true 转换为 1// \"1\" 转换为 1\"1,2\" == [1,2]// [1,2] 转换为字符串 \"1,2\"","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]},{"title":"高效操作DOM","slug":"高效操作DOM","date":"2015-08-09T13:21:37.000Z","updated":"2017-02-14T02:25:10.000Z","comments":true,"path":"2015/08/09/高效操作DOM/","link":"","permalink":"http://www.cheneyliu.com/2015/08/09/高效操作DOM/","excerpt":"DOM树与Render树这个应该都是知道的。就是用户请求HTML下来后，浏览器渲染引擎的基本工作中两个概念。copy一张图，流程大概就是：解析html构建DOM树，渲染树构建，渲染树布局，绘制渲染树。这里要注意的一点是，DOM树和render树并不是简单的一一对应关系。render树中并不包含那些不需要渲染的节点。比方说head、title这样的；display：none也是不会有的；还有一些设置position:absolute，fixed，构造render树时会根据实际情况来构造。","text":"DOM树与Render树这个应该都是知道的。就是用户请求HTML下来后，浏览器渲染引擎的基本工作中两个概念。copy一张图，流程大概就是：解析html构建DOM树，渲染树构建，渲染树布局，绘制渲染树。这里要注意的一点是，DOM树和render树并不是简单的一一对应关系。render树中并不包含那些不需要渲染的节点。比方说head、title这样的；display：none也是不会有的；还有一些设置position:absolute，fixed，构造render树时会根据实际情况来构造。 重绘(redraw)和重排(reflow)从字面上就是能理解了，重绘就是重新绘制，重排就是重构render树。这两个都是负担很重的操作，比方说table tree中显示隐藏，浏览器需要重排，重绘，如果子节点比较多，有可能页面就卡死了（ie6、7这样的老古董很容易会这样）。所以这样的事情我们尽量少做，也就是写js的时候尽量少些这样类型的代码。而重排一般都是下面这样的操作引起的（尽量少的使用）。1.添加、删除可见的DOM元素(visibility:hidden也算，不要为为什么)2.元素的位置改变3.元素尺寸改变，也就是盒子模型中的属性改变4.内容改变（文本加长了，图片尺寸改变）5.浏览器窗格改变大小6.获取某些属性（offset，scroll，client**） 最小化重绘与重排1.合并css操作为一次操作2.当要批量修改dom时，先将该元素中文档流中摘除，对其使用多重改变，最后将元素带回文档中。（设置display：none;使用DocumentFragment;clone一个节点）3.在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。4.将需要多次重排的元素（比方说动画），position属性设为absolute或fixed，使其脱离文档流，这样它的变化不会影响到其他元素。 DOM 真的很慢如果把ECMAScript看做一个孤岛，DOM看做一个孤岛，DOM访问看成是过桥的话，每次DOM访问都是需要”过桥费”的。过的多，费用就越高，也就越消耗性能。所以尽量减少DOM的访问。比方缓存获取下来的DOM元素。","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]},{"title":"javascript作用域链","slug":"javascript作用域链","date":"2015-08-02T15:30:01.000Z","updated":"2017-02-08T07:16:03.000Z","comments":true,"path":"2015/08/02/javascript作用域链/","link":"","permalink":"http://www.cheneyliu.com/2015/08/02/javascript作用域链/","excerpt":"最近想整理一下js执行代码的一些知识，如果有出错的地方还请指正。 执行环境(Execution Context)所有的javascript代码都是在一个执行环境中被执行的。它只是一种机制，用来完成运行时作用域、生存期等方面的处理。代码分为三种类型：1.Global Code2.Eval Code3.Function Code这是一个EC结构可以理解如下：12345678activeExecutionContext = &#123; VO: &#123;...&#125;, // or AO this: thisValue, Scope: [ // Scope chain // 所有变量对象的列表 // for identifiers lookup ]&#125;;","text":"最近想整理一下js执行代码的一些知识，如果有出错的地方还请指正。 执行环境(Execution Context)所有的javascript代码都是在一个执行环境中被执行的。它只是一种机制，用来完成运行时作用域、生存期等方面的处理。代码分为三种类型：1.Global Code2.Eval Code3.Function Code这是一个EC结构可以理解如下：12345678activeExecutionContext = &#123; VO: &#123;...&#125;, // or AO this: thisValue, Scope: [ // Scope chain // 所有变量对象的列表 // for identifiers lookup ]&#125;; 当一段程序开始时，会先进入到全局执行上下文环境。此时如果调用了某些函数，就会进入他们的上下文环境，执行完之后再退出该上下文环境。假设激活了一个EC1的上下文，图解如下 变量对象(VO)和活动对象(AO)变量对象是一个与上下文相关的数据作用域，用于存储被定义在上下文中的变量和函数声明（不包括函数表达式）。在global全局上下文中，变量对象即使全局对象自身。copy一个例子1234567891011var foo = 10;function bar() &#123;&#125; // // 函数声明(function baz() &#123;&#125;); // 函数表达式console.log( this.foo == foo, // true window.bar == bar // true);console.log(baz); // 引用错误，baz没有被定义 全局上下文中的变量对象(VO)会有如下属性：在一个函数的上下文中，变量对象被表示为活动对象活动对象在进入上下文中初始化成了123AO = &#123; arguments: &lt;ArgO&gt;&#125;; arguments属性值就是Arguments对象之后就是存储当前上下文的变量与函数声明 作用域链作用域链是一个 对象列表，用于检索上下文中出现的 标识符（变量名称、函数声明，普通参数）。在函数创建的时候，当前的作用域链被存储到了函数的[[scope]]属性中。当进入上下文创建AO/VO之后，上下文(EC)的Scope属性作了如下处理：1Scope = AO|VO + [[Scope]] 知识点就是这些，现在我们来一段代码，把过程给串联起来。在这之前，我们要知道另一个知识，就是执行上下文的代码被分成两个基本的阶段来处理1.进入执行上下文2.执行代码1234567891011121314var x = 10;function foo(m) &#123; var y = 20; function bar() &#123; var z = 30; alert(x + y + z + m); &#125; bar();&#125;foo(10); // 60 首先先进入全局上下文环境全局上下文的变量对象(代码执行时，x才被赋值)是：1234globalContext.VO === Global = &#123; x: 10 foo: &lt;reference to function&gt;&#125;; globalContext.Scope = globalContext.VO;当”foo”创建时，1234567foo.[[Scope]] = [ globalContext.Scope];//也就是foo.[[Scope]] = [ globalContext.VO]; 在”foo”激活时，进入了foo的上下文，foo上下文中的活动对象(代码执行时，y才被赋值)是：123456fooContext.AO = &#123; arguments:&lt;Arg&gt;, m: 10, y: 20, bar: &lt;reference to function&gt;&#125;; 此时foo上下文中的作用域链为：12345fooContext.Scope = fooContext.AO + foo.[[Scope]] // i.e.:fooContext.Scope = [ fooContext.AO, globalContext.VO]; 函数”bar”创建时，其[[scope]]为:123456bar.[[Scope]] = fooContext.Scope;//也就是bar.[[Scope]] = [ fooContext.AO, globalContext.VO]; 同理，bar就不写了。最后bar上下文的作用域链为:123456barContext.Scope = barContext.AO + bar.[[Scope]]barContext.Scope = [ barContext.AO, fooContext.AO, globalContext.VO]; 在alert执行时，作用域链中查找标示符如下查找 x, barContext.AO 无 —-&gt; fooContext.AO 无 —-&gt;globalContext.VO 有查找 Z, barContext.AO 有其他的就自己看了。 局部变量、全局变量在作用域链中查找标识符是需要花时间的，所以就明白为什么需要尽量使用局部变量(将频繁使用的全局变量缓存下来)，全局变量尽量少用了。并且with会破坏作用域链，它会将指定的VO/AO加入到作用域链的顶端，这样在标识符查找时，需要查找更长的作用域链。 闭包理解了上面的概念，闭包就很容易理解了。闭包是代码块和创建该代码块的上下文中数据的结合。","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]},{"title":"javascript原型和原型链","slug":"javascript原型和原型链","date":"2015-07-29T15:12:27.000Z","updated":"2017-02-08T07:13:38.000Z","comments":true,"path":"2015/07/29/javascript原型和原型链/","link":"","permalink":"http://www.cheneyliu.com/2015/07/29/javascript原型和原型链/","excerpt":"最近几天，好些新同事来问原型，原型链啥的。本身作为菜鸟的我好像也没有好好整理过这个，这里写写自己的理解。 原型大家都知道，JavaScript 不包含传统的类继承模型，而是使用 prototype 原型模型。代码实现大概是这样子的123456789101112function Student(name)&#123; this.name = name;&#125;var Kimy = new Student(\"Kimy\");Student.prototype.say = function()&#123; console.log(this.name + \"say\");&#125;Kimy.say();//Kimysay Kimy本身是没有say方法的，当他在自己对象中找不到该方法时就回去他的原型中查找，也就是Student.prototype对象中查找。这里我们用到了一个构造函数Student","text":"最近几天，好些新同事来问原型，原型链啥的。本身作为菜鸟的我好像也没有好好整理过这个，这里写写自己的理解。 原型大家都知道，JavaScript 不包含传统的类继承模型，而是使用 prototype 原型模型。代码实现大概是这样子的123456789101112function Student(name)&#123; this.name = name;&#125;var Kimy = new Student(\"Kimy\");Student.prototype.say = function()&#123; console.log(this.name + \"say\");&#125;Kimy.say();//Kimysay Kimy本身是没有say方法的，当他在自己对象中找不到该方法时就回去他的原型中查找，也就是Student.prototype对象中查找。这里我们用到了一个构造函数Student 构造函数、proto以及原型链除了IE浏览器，其他浏览器都在Object对象的实例上，部署了一个非标准的proto属性（前后各两个下划线），指向该对象的原型对象，即构造函数的prototype属性。盗用一段代码和一张图123456789101112131415161718192021222324252627282930313233// 构造方法function Foo(y) &#123; this.y = y;&#125;Foo.prototype.x = 10;// 继承方法\"calculate\"Foo.prototype.calculate = function (z) &#123; return this.x + this.y + z;&#125;;// 使用foo模式创建 \"b\" and \"c\"var b = new Foo(20);var c = new Foo(30);// 调用继承的方法b.calculate(30); // 60c.calculate(40); // 80console.log( b.__proto__ === Foo.prototype, // true c.__proto__ === Foo.prototype, // true b.constructor === Foo, // true c.constructor === Foo, // true Foo.prototype.constructor === Foo // true b.calculate === b.__proto__.calculate, // true b.__proto__.calculate === Foo.prototype.calculate // true); 我们可以看到，每个对象都是含有一个proto属性，b的proto指向的构造b的构造方法Foo的prototype属性；而Foo.prototype也是一个对象，本身也有一个proto指向构造其的构造方法Object的prototype。Object.prototype的proto被指向了 null, 这就形成了一个原型链了。这里还要能理解这样一段代码1234Object instanceof Function//trueFunction instanceof Object//true new做了什么这里还有一个小问题，js里面普通函数和构造函数形式上貌似没有啥太大区别(首字母大写不是必须的，但是通常都把构造函数的首字母大写)。new这个关键字到底做了什么东西。比方1var Kimy = new Student(); new 做了三件事情12345var Kimy = &#123;&#125;;Kimy.__proto__ = Student.prototype;Student.call(Kimy); 1、定义了一个空对象2、设置其原型3、初始化对象这样就能理解为什么Kimy.proto指向的是Student.prototype了(同一个引用)，原来就是new在起着关键的作用！","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]},{"title":"setTimeout与setInterval","slug":"setTimeout与setInterval","date":"2015-06-22T15:23:33.000Z","updated":"2017-02-08T07:13:18.000Z","comments":true,"path":"2015/06/22/setTimeout与setInterval/","link":"","permalink":"http://www.cheneyliu.com/2015/06/22/setTimeout与setInterval/","excerpt":"最新写代码中时，看到项目中有人用到了 setTimeout(fun,0)，于是想总结一下。个人理解，如果有错误的地方还请指出。THX要想理解JavaScript的定时器是如何工作的，先要明白 JavaScript 引擎是单线程的。这个可以理解为 javascript 引擎是一个服务员，它有一个服务的队列，所有的界面元素事件,定时触发器回调，异步请求回调都要在这个任务队列里排队，等待处理。所有任务都是一个最小单位，不会中断处理。这样就可以理解 setTimeout(fun,0) 了，它并不是代表立即执行该代码，除非任务队列为空(事实上，各个浏览器在实际执行这个的时候也是有差异了，比较新的浏览器实际可能是在4ms；老版本的可能更长一点，16ms也是可能的)。而 setTimeout(fun,time) 的意思就是多少时间后将 fun 回调加到这个任务队列中，也就是至少需要time时间才会执行fun。举个例子：12345678setTimeout(function () &#123; console.log(1);&#125;, 0);var tem = 0;for (var i = 1; i &lt; 1000000; i++) &#123; tem += i;&#125;;console.log(2); 显示结果为1221 就是说，在执行 setTimeout 时，将 function 回调加入了任务队列，但并没有立即执行，因为js引擎还在忙着处理当前的js，而只在这段代码段执行完才去任务列表里取新的任务，所以结果就是先显示 2 后显示 1。","text":"最新写代码中时，看到项目中有人用到了 setTimeout(fun,0)，于是想总结一下。个人理解，如果有错误的地方还请指出。THX要想理解JavaScript的定时器是如何工作的，先要明白 JavaScript 引擎是单线程的。这个可以理解为 javascript 引擎是一个服务员，它有一个服务的队列，所有的界面元素事件,定时触发器回调，异步请求回调都要在这个任务队列里排队，等待处理。所有任务都是一个最小单位，不会中断处理。这样就可以理解 setTimeout(fun,0) 了，它并不是代表立即执行该代码，除非任务队列为空(事实上，各个浏览器在实际执行这个的时候也是有差异了，比较新的浏览器实际可能是在4ms；老版本的可能更长一点，16ms也是可能的)。而 setTimeout(fun,time) 的意思就是多少时间后将 fun 回调加到这个任务队列中，也就是至少需要time时间才会执行fun。举个例子：12345678setTimeout(function () &#123; console.log(1);&#125;, 0);var tem = 0;for (var i = 1; i &lt; 1000000; i++) &#123; tem += i;&#125;;console.log(2); 显示结果为1221 就是说，在执行 setTimeout 时，将 function 回调加入了任务队列，但并没有立即执行，因为js引擎还在忙着处理当前的js，而只在这段代码段执行完才去任务列表里取新的任务，所以结果就是先显示 2 后显示 1。setInterval(fun, time)方法是，每隔一定时间将fun添加到队列中，那么问题来，如果fun执行时间比 time 要长的时候怎么办？看一段代码12345678910111213var num = 0;var time = setInterval(function () &#123; var tem = 0; for (var i = 1; i &lt; 99999999; i++) &#123; tem += i; &#125;; num ++; console.log(num);&#125;, 100);setTimeout(function ()&#123; clearInterval(time);&#125;, 1000); 意思是每隔100ms执行一段代码，在1s中后清除这个定时器。但是结果呢？显示结果为123123 也就是说，事实上，并没有执行到那么多次数。也就是说某些间隔会被跳过，这也就存在多个代码执行的间隔可能会比预期的小。原来在将定时器代码加入队列的时候，如果该定时器的代码实例存在时，该次定时器代码会被跳过。引用一张图片，就很好理解了。","categories":[{"name":"web","slug":"web","permalink":"http://www.cheneyliu.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.cheneyliu.com/tags/javascript/"}]}]}